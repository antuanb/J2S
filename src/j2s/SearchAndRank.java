package j2s;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jsoup.Jsoup;

import com.google.code.stackexchange.client.StackExchangeApiClient;
import com.google.code.stackexchange.client.StackExchangeApiClientFactory;
import com.google.code.stackexchange.schema.Answer;
import com.google.code.stackexchange.schema.Question;
import com.google.code.stackexchange.schema.StackExchangeSite;

public class SearchAndRank {
	
	public static void resetStaticVariables() {
		fullKeywordSet = new ArrayList<String>();
		tempKeyword.clear();
		finalStackOverflowResultsList.clear();

		totalUniqueTokens.clear();
		finalList.clear();
		sortedFinalRanking.clear();
		DSet.clear();
	}

	private static ArrayList<HashMap<Answer, Question>> queryResultStackOverflow;
	private static ArrayList<HashMap<String, String>> queryResultGoogleStack;
	private static ArrayList<HashMap<String, String>> queryResultGoogleAll;
	private static ArrayList<String> fullKeywordSet = new ArrayList<String>();
	private static ArrayList<String> tempKeyword = new ArrayList<String>();
	private static ArrayList<AnswerWrapper> finalStackOverflowResultsList = new ArrayList<AnswerWrapper>();

	public static ArrayList<String> totalUniqueTokens = new ArrayList<String>();
	private static HashSet<String> filterKeys;
	private static ArrayList<MetaData> finalList = new ArrayList<MetaData>();

	public static ArrayList<MetaData> sortedFinalRanking = new ArrayList<MetaData>();
	public static int DCount = 1;
	public static ArrayList<Set<String>> DSet = new ArrayList<Set<String>>();
	private static final double alpha = 0.6;
	private static final double beta = 0.4;

	private static final boolean TEST_THROTTLE = false;

	static {
		filterKeys = new HashSet<String>();
		filterKeys.add(" ");
		filterKeys.add("public");
		filterKeys.add("func");
		filterKeys.add("wrapper");
		filterKeys.add("to");
		filterKeys.add("\n");
		filterKeys.add(".");
		filterKeys.add(",");
		filterKeys.add(":");
		filterKeys.add(";");
		filterKeys.add("'");
		filterKeys.add("");
		filterKeys.add("{");
		filterKeys.add("}");
		filterKeys.add("[");
		filterKeys.add("]");
		filterKeys.add("?");
		filterKeys.add("-");
		filterKeys.add(">");
		filterKeys.add("<");
		filterKeys.add("=");
		filterKeys.add("@");
		filterKeys.add("!");
		filterKeys.add("\\");
		filterKeys.add("\"");
		filterKeys.add("%");
		filterKeys.add("*");
		filterKeys.add("/");
		filterKeys.add("*=");
		filterKeys.add("\"=");
		filterKeys.add("the");
		filterKeys.add("this");
		filterKeys.add("//");
		filterKeys.add("/");
		filterKeys.add("*/");
	}

	public SearchAndRank(ArrayList<String> searchKeywords, PrintWriter outputWriter) throws IOException, ClassNotFoundException {
		System.out.println("start");
		initKeywordSet(searchKeywords);
		System.out.println("mid");
		if (outputWriter != null) {
			outputWriter.println("Pre-rank");
		}
		boolean success = search(outputWriter);
		if (success) {
			
		System.out.println("search");
		// writeObject();
		//System.out.println("writing");
		if (outputWriter != null) {
			outputWriter.println("Our Rank");
		}
		rank(outputWriter);
		System.out.println("sorted and ranked, final list size is: " + sortedFinalRanking.size());
		System.out.println("finalStackOverflowResultsList size: " + finalStackOverflowResultsList.size());
		} else {
			throw new IOException("TimeOut");
		}
	}
	
	public static void synthesize(int index) {
		DateFormat dateFormat = new SimpleDateFormat("yyyyMMdd-HHmmss");
		Date date = new Date();
		String curDateTime = dateFormat.format(date);
		PrintWriter writer = null;
		String filename = System.getProperty("user.home") + "/Downloads/AutoGeneratedSwift-"+curDateTime + ".swift";
		File file = new File(filename);
		file.getParentFile().mkdirs();
		try {
			writer = new PrintWriter(file, "UTF-8");
			writer.println("// Auto-generated Swift file from Native-2-Native");
			writer.println();
			for (String s : GenerateSwiftQueryString.controlFlowCode) {
				//something like this?
				if (s.equals("INSERT RESULT")) {
					writer.println("\r\n /* NATIVE-2-NATIVE RESULT\r\n" 
							+ sortedFinalRanking.get(index).getAnswerBody().toString() + "\r\n*/");
				} else if (!s.equals("")) {
					writer.println(s);
				}
			}
			writer.close();
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			e.printStackTrace();
			System.out.println("Failed to write file! " + e.getMessage());
		}
	}

	private void writeObject() throws IOException {
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("finalStackOverflowResultsList.txt"));
		oos.writeObject(finalStackOverflowResultsList);
		oos.flush();
		oos.close();
		System.out.println(finalStackOverflowResultsList.size() + " size before");
	}

	private void readObject() throws IOException, ClassNotFoundException {
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("finalStackOverflowResultsList.txt"));
		@SuppressWarnings("unchecked")
		ArrayList<AnswerWrapper> list = (ArrayList<AnswerWrapper>) ois.readObject();
		ois.close();
		System.out.println(list.size() + " size after");
	}

	private static void initKeywordSet(ArrayList<String> searchKeywords) {
		String concatenatedKeywords = "";
		for (String keyword : searchKeywords) {
			concatenatedKeywords += keyword + " ";
		}
		fullKeywordSet.add(concatenatedKeywords);

		// for (int i = 0; i < searchKeywords.size(); i++) {
		// fullKeywordSet.add(searchKeywords.get(i));
		// }
		// permutation(searchKeywords);
		// for (int i = 0; i < tempKeyword.size(); i++) {
		// fullKeywordSet.add(tempKeyword.get(i).trim());
		// }
		if (searchKeywords.size() > 1) {
//			fullKeywordSet.add(searchKeywords.get(0) + " " + searchKeywords.get(1));
			// fullKeywordSet.add(searchKeywords.get(1) + " "
			// + searchKeywords.get(0));
		}
	}

	private boolean search(PrintWriter outputWriter) {
		for (String keyword : fullKeywordSet) {
//			queryResultStackOverflow = ScrapeDataWithKeywords.executeStackOverflowQuery(keyword);
//			for (int i = 0; i < queryResultStackOverflow.size(); i++) {
//
//				Iterator<Answer> answerIterator = queryResultStackOverflow.get(i).keySet().iterator();
//				Answer answer = answerIterator.next();
//				Question question = queryResultStackOverflow.get(i).get(answer);		
//
//				AnswerWrapper aw = new AnswerWrapper(question, answer, 1.0 - (double) (i + 1)
//						/ queryResultStackOverflow.size());
//				finalStackOverflowResultsList.add(aw);
//			}

			queryResultGoogleStack = ScrapeDataWithKeywords.executeGoogleSearchQuery_Stack(keyword);
			if (queryResultGoogleStack == null) {
				return false;
			}
			if (TEST_THROTTLE) {
				try {
					Thread.sleep(60000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}

			for (int i = 0; i < queryResultGoogleStack.size(); i++) {
				ArrayList<HashMap<Answer, Question>> noAnswerCheck = ScrapeDataWithKeywords.executeStackOverflowQuery(queryResultGoogleStack.get(i)
						.get("id"));
				for (int j = 0; j < noAnswerCheck.size(); j++) {

					if (noAnswerCheck.size() == 0) {
						continue;
					}
					Iterator<Answer> answerIterator = noAnswerCheck.get(j).keySet().iterator();
					Answer answer = answerIterator.next();
					Question question = noAnswerCheck.get(j).get(answer);

					AnswerWrapper aw = new AnswerWrapper(question, answer, 1.0 - (double) (j + 1) / queryResultGoogleStack.size());
					System.out.println(aw);
					if (outputWriter != null) {
						outputWriter.println(aw + "," + (i + 1));
					}
					
					J2SView.PreRank.add(aw.toString());
					aw.getAnswer().setTitle(question.getTitle());

					//debug purposes
					/*
					System.out.println("a id: " + aw.getQuestion().getQuestionId());
					System.out.println("a id: " + aw.getAnswer().getAnswerId());
					System.out.println("A: viewcount: " + aw.getAnswer().getViewCount());
					System.out.println("Q: viewcount: " + aw.getQuestion().getViewCount());
					System.out.println("score: " + aw.getAnswer().getScore());
					System.out.println("title: " + aw.getAnswer().getTitle());
					System.out.println("q score: " + aw.getQuestion().getScore());
					System.out.println("q fav: " + aw.getQuestion().getFavoriteCount());
					System.out.println("q upvote: " + aw.getQuestion().getUpVoteCount());
					System.out.println("a downvote: " + aw.getAnswer().getDownVoteCount());
					System.out.println("a fav " + aw.getAnswer().getFavoriteCount());
					*/
					finalStackOverflowResultsList.add(aw);
				}
				if (TEST_THROTTLE) {
					try {
						Thread.sleep(60000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
			if (outputWriter != null) {
				outputWriter.println();
				outputWriter.println("Google Rank");
				outputWriter.println(finalStackOverflowResultsList.get(0) + ",1");
				outputWriter.println(finalStackOverflowResultsList.get(1) + ",2");
				outputWriter.println();
			}

			// make global static list of whatever item we use to store these
			// non stackoverflow posts
			// store not just the code but any feature information we can infer
			// here
			// queryResultGoogleAll =
			// ScrapeDataWithKeywords.executeGoogleSearchQuery_All(keyword);
			// for (int i = 0; i < queryResultGoogleAll.size(); i++) {
			// do something with each all query result
			// }
		}
		return true;

	}

	private void rank(PrintWriter outputWriter) {
		HashMap<Long, MetaData> metaDataList = new HashMap<Long, MetaData>();
		HashSet<Long> uniques = new HashSet<Long>();
		DSet.add(GenerateSwiftQueryString.mdQuery.getFrequency().keySet());
		System.out.println("size of aw: " + finalStackOverflowResultsList.size());
		for (AnswerWrapper aw : finalStackOverflowResultsList) {
			if (!uniques.contains(aw.getAnswer().getAnswerId())) {
							
				uniques.add(aw.getAnswer().getAnswerId());
				
				MetaData md = new MetaData();
				md.setID(aw.getAnswer().getAnswerId());
				md.setNumDownVotes(aw.getAnswer().getDownVoteCount());
				md.setNumFav(aw.getAnswer().getFavoriteCount());
				md.setNumInQuery(aw.getRank());
				md.setNumViews(aw.getAnswer().getViewCount());
				md.setNumVotes(aw.getAnswer().getScore());
				md.setAnswerBody(ScrapeDataWithKeywords.parseHTMLForCode(aw.getAnswer().getBody()));
				
				//fields from question
				md.setQuestionFavoriteCount(aw.getQuestion().getFavoriteCount());
				md.setQuestionScore(aw.getQuestion().getScore());
				md.setQuestionTitle(aw.getQuestion().getTitle());
				md.setQuestionUpVoteCount(aw.getQuestion().getUpVoteCount());
				md.setQuestionViewCount(aw.getQuestion().getViewCount());
				md.setApprovedAnswer(aw.getQuestion().getAcceptedAnswerId());

				HashSet<String> titleTokens = createTitleTokens(aw.getAnswer().getTitle());
				md.setTitleTokens(titleTokens);

				HashMap<String, Integer> frequency = createTokenFrequency(aw, true);
				md.setFrequency(frequency);
				DSet.add(frequency.keySet());
				DCount++;
				metaDataList.put(aw.getAnswer().getAnswerId(), md);
			} else {
				// not sure if this is how java works?
				// might not actually be setting this so need to test
				metaDataList.get(aw.getAnswer().getAnswerId()).setNumQueryAppear();
			}
		}

		// need to do same stuff for the non stack overflow results once we know
		// how those are stored
		// that is done here and make new metadata objects as well
		
		Iterator it = metaDataList.entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry pair = (Map.Entry) it.next();
			finalList.add((MetaData) pair.getValue());
			it.remove();
		}
		Collections.sort(finalList, new MetaDataComparator());
		Collections.reverse(finalList);

		double[] cosines = new double[finalList.size()];
		for (int i = 0; i < finalList.size(); i++) {
			cosines[i] = GenerateSwiftQueryString.mdQuery.getCosValue(finalList.get(i));
			finalList.get(i).setCosValueFinal(cosines[i]);
		}
		cosines = normalize(cosines);
		HashMap<Double, MetaData> finalRanking = new HashMap<Double, MetaData>();
		for (int i = 0; i < finalList.size(); i++) {
			cosines[i] = (alpha * cosines[i]) + (beta * finalList.get(i).getNormLinScore());
			finalRanking.put(cosines[i], finalList.get(i));
			finalList.get(i).setFinalRankingScore(cosines[i]);
		}
		List<Map.Entry<Double, MetaData>> list = new LinkedList<>(finalRanking.entrySet());
		Collections.sort(list, new Comparator<Map.Entry<Double, MetaData>>() {
			@Override
			public int compare(Entry<Double, MetaData> arg0, Entry<Double, MetaData> arg1) {
				return (arg0.getKey()).compareTo(arg1.getKey());
			}
		});
		Collections.reverse(list);
		sortedFinalRanking = new ArrayList<MetaData>();
		for (Map.Entry<Double, MetaData> entry : list) {
			MetaData data = entry.getValue();
			System.out.println(data);
			if (outputWriter != null) {
				outputWriter.println(data + ",");
			}
			
			sortedFinalRanking.add(data);
		}
	}

	private static double[] normalize(double[] cosines) {
		float max = 0;
		for (int i = 0; i < finalList.size(); i++) {
			if (finalList.get(i).getLinearScore() > max) {
				max = finalList.get(i).getLinearScore();
			}
		}
		for (int i = 0; i < finalList.size(); i++) {
			finalList.get(i).setNormLinScore(finalList.get(i).getLinearScore() / max);
		}
		double maxCos = -1.0;
		double[] newCosines = new double[cosines.length];
		for (int i = 0; i < cosines.length; i++) {
			if (cosines[i] > maxCos) {
				maxCos = cosines[i];
			}
		}
		for (int i = 0; i < cosines.length; i++) {
			newCosines[i] = cosines[i]/maxCos;
		}
		return newCosines;
	}

	public static HashMap<String, Integer> createTokenFrequency(AnswerWrapper aw, boolean flag) {

		HashMap<String, Integer> frequency = new HashMap<String, Integer>();

		String answerBody = aw.getAnswer().getBody();
		String questionTitle = aw.getAnswer().getTitle();
		String input = questionTitle + " " + answerBody;

		input = Jsoup.parse(input).text(); // Remove HTML tags

		// Remove Comments
		if (flag) 
			input = input.replaceAll("//.*|(\"(?:\\\\[^\"]|\\\\\"|.)*?\")|(?s)/\\*.*?\\*/", "$1 ");

		List<String> tokens = process(input); // Custom preprocessor by IBM

		ArrayList<String> tempTokens = new ArrayList<String>(tokens);

		ArrayList<String> finalTokens = new ArrayList<String>();

		for (String token : tempTokens) {
			// camelCase, Class/method names etc
			String[] codeTokens = token.split("(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|([0-9]+)|=|(\\()|(\\))|(\\.)|(\\_)|(\\n)|(\\-)|(\\')");//|(([a-z]|[A-Z])([0-9])([a-z]|[A-Z]))");
			for (int i = 0; i < codeTokens.length; i++) {
				codeTokens[i] = codeTokens[i].toLowerCase();
			}
			finalTokens.addAll(Arrays.asList(codeTokens));
		}

		filterTokens(finalTokens); // remove punctuation, symbols etc

		for (String t : finalTokens) {
			t = t.toLowerCase();
			t = filterHashMap(t);
			//t = applyStemming(t);
			if (t != "") {
				if (frequency.containsKey(t)) {
					frequency.put(t, frequency.get(t) + 1);
				} else {
					frequency.put(t, 1);
				}
			}
		}

		ArrayList<String> uniqueLocalFrequencyList = GenerateSwiftQueryString.sortByValue(frequency);
		removeCorpusDuplicates(uniqueLocalFrequencyList);
		totalUniqueTokens.addAll(uniqueLocalFrequencyList);

		return frequency;
	}
	
	public static String filterHashMap(String t) {
		String token = t;
		if (t.contains("map")) {
			token = "dictionary";
		} else if (t.contains("hash")) {
			return "";
		}
		return token;
	}

	private static void removeCorpusDuplicates(ArrayList<String> uniqueLocalFrequencyList) {
		ArrayList<String> tempList = new ArrayList<String>(uniqueLocalFrequencyList);
		for (String token : tempList) {
			if (totalUniqueTokens.contains(token)) {
				uniqueLocalFrequencyList.remove(token);
			}
		}
	}

	public static String applyStemming(String t) {
		String token = t;
		if (t.endsWith("ing")) {
			token = t.substring(0, t.length() - 3);
		}
		return token;
	}

	private static void filterTokens(ArrayList<String> tokens) {
		for (String key : filterKeys) {
//			if (tokens.contains(key)) {
				while (tokens.remove(key)) {

				}
//			}
		}
	}

	public static List<String> process(String input) {
		List<String> tokens = new ArrayList<String>();
		StringBuilder sb = new StringBuilder();

		char[] arr = input.toCharArray();
		for (int i = 0; i < arr.length; i++) {

			char prior = (i - 1 > 0) ? arr[i - 1] : ' ';
			char current = arr[i];
			char next = (i + 1 < arr.length) ? arr[i + 1] : ' ';

			// extract acronyms
			// this will actually extract acronyms of any length
			// once it detects this pattern a.b.c
			// it's a greedy lexer that breaks at ' '
			if (Character.isLetter(current) && '.' == next) {

				// Pattern-1 = U.S.A (5 chars)
				// Pattern-2 = U.S.A. (6 chars)
				if (i + 5 < input.length()) {

					// Pattern-1
					if (Character.isLetter(arr[i]) && '.' == arr[i + 1] && Character.isLetter(arr[i + 2]) && '.' == arr[i + 3]
							&& Character.isLetter(arr[i + 4])) {

						for (; i < arr.length && arr[i] != ' '; i++) {
							sb.append(arr[i]);
						}

						// check for Pattern-2 (trailing '.')
						if (i + 1 < input.length() && '.' == arr[i + 1]) {
							sb.append(arr[i++]);
						}

						addToken(tokens, sb);
						sb = new StringBuilder();
						continue;
					}
				}
			}

			if ('w' == current && '/' == next) {
				sb.append(current);
				sb.append(next);
				addToken(tokens, sb);
				sb = new StringBuilder();
				i += 1;
				continue;
			}

			// extract URLs
			if ('h' == current && 't' == next) {
				if (i + 7 < input.length() && "http://".equals(input.substring(i, i + 7))) {

					for (; i < arr.length && arr[i] != ' '; i++) {
						sb.append(arr[i]);
					}

					addToken(tokens, sb);
					sb = new StringBuilder();
					continue;
				}
			}

			// extract windows drive letter paths
			// c:/ or c:\
			if (Character.isLetter(current) && ':' == next) {
				if (i + 2 < input.length() && (arr[i + 2] == '\\' || arr[i + 2] == '/')) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// keep numbers together when separated by a period
			// "4.0" should not be tokenized as { "4", ".", "0" }
			if (Character.isDigit(current) && '.' == next) {
				if (i + 2 < input.length() && Character.isDigit(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// keep alpha characters separated by hyphens together
			// "b-node" should not be tokenized as { "b", "-", "node" }
			if (Character.isLetter(current) && '-' == next) {
				if (i + 2 < input.length() && Character.isLetter(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// need a greedy look-ahead to
			// avoid splitting this into multiple tokens
			// "redbook@vnet.ibm.com" currently is
			// tokenized as { "redbook@vnet", ".", "ibm", ".", "com" }
			// need to greedily lex all tokens up to the space
			// once the space is found, see if the last 4 chars are '.com'
			// if so, then take the entire segment as a single token
			// don't separate tokens concatenated with an underscore
			// eg. "ws_srv01" is a single token, not { "ws", "_", "srv01" }
			if (Character.isLetter(current) && '_' == next) {
				if (i + 2 < input.length() && Character.isLetter(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					i++;
					continue;
				}
			}

			// extract twitter channels
			if (('#' == current || '@' == current) && ' ' != next) {// &&
																	// !CodeUtilities.isSpecial(next))
																	// {
				sb.append(current);
				continue;
			}

			// keep tokens like tcp/ip and os/2 and system/z together
			if (' ' != current && '/' == next) {
				sb.append(current);
				sb.append(next);
				i++;
				continue;
			}

			if (' ' == current) {
				addToken(tokens, sb);
				sb = new StringBuilder();
				continue;
			}

			// don't tokenize on <word>'s or <words>'
			// but do tokenize on '<words>
			if ('\'' == current) {
				if (' ' == prior) {
					addToken(tokens, "'");
				} else {
					sb.append(current);
				}

				continue;
			}

			if (!Character.isLetterOrDigit(current)) {
				addToken(tokens, sb);
				addToken(tokens, String.valueOf(current));
				sb = new StringBuilder();
				continue;
			}

			sb.append(current);
		}

		if (0 != sb.length()) {
			addToken(tokens, sb);
		}

		return tokens;
	}

	protected static void addToken(List<String> tokens, String text) {
		if (!text.isEmpty()) {
			tokens.add(text);
		}
	}

	protected static void addToken(List<String> tokens, StringBuilder buffer) {
		if (null != buffer && 0 != buffer.length()) {
			addToken(tokens, buffer.toString().trim());
		}
	}

	public static void main(String[] args) {
		// StackExchangeApiClientFactory clientFactory =
		// StackExchangeApiClientFactory.newInstance(null,
		// StackExchangeSite.STACK_OVERFLOW);
		// StackExchangeApiClient client =
		// clientFactory.createStackExchangeApiClient();

		// HashMap<String, Integer> frequency =
		// createTokenFrequency(client.getAnswers("WITHBODY", 24088081).get(0));
		// HashMap<String, Integer> frequency2 =
		// createTokenFrequency(client.getAnswers("WITHBODY", 24696739).get(0));

		// System.out.println(SearchAndRank.totalUniqueTokens.size());
	}

	public static String getQuestionTitle(long questionID) {
		StackExchangeApiClientFactory clientFactory = StackExchangeApiClientFactory.newInstance(ScrapeDataWithKeywords.AUTH_KEY,
				StackExchangeSite.STACK_OVERFLOW);
		StackExchangeApiClient client = clientFactory.createStackExchangeApiClient();

		return client.getQuestions(questionID).get(0).getTitle();
	}

	private HashSet<String> createTitleTokens(String title) {
		HashSet<String> titleTokens = new HashSet<String>();
		if (title == null) {
			titleTokens.add(" ");
			return titleTokens;
		}
		String[] tokens = title.split(" ");
		for (String s : tokens) {
			s = s.toLowerCase().trim();
			if (s.endsWith("?") || s.endsWith("!")) {
				s = s.substring(0, s.length() - 1);
			}
			titleTokens.add(s);
		}
		return titleTokens;
	}

	public static void permutation(ArrayList<String> str) {
		permutation("", str);
	}

	private static void permutation(String prefix, ArrayList<String> str) {
		int n = str.size();
		if (n == 0) {
			tempKeyword.add(prefix);
		} else {
			for (int i = 0; i < n; i++) {
				ArrayList<String> temp = new ArrayList<String>();
				for (int j = 0; j < i; j++) {
					temp.add(str.get(j));
				}
				for (int j = i + 1; j < n; j++) {
					temp.add(str.get(j));
				}
				permutation(prefix + str.get(i) + " ", temp);
			}
		}
	}

}
